%class Parser
%package edu.semo.jatsz.glang
%interface Tokens
%next next()
%get lexer.getToken()
%semantic Object : lexer.getValue()
%token EQUAL ID SUB ADD LPAREN RPAREN SEMI LITERAL ALPHA ALPHANUM LCURLY RCURLY LSQUARE RSQUARE STRING CHAR CHARACTER CHARS DQUOTE QUOTE
%token INT DOUBLE PRINT READ WHILE FOR
%right EQUAL
%left MULTIPLY DIVIDE
%left POW


%{
import edu.semo.jatsz.glang.parsenode.*;
import edu.semo.jatsz.glang.parsenode.statement.*;
import edu.semo.jatsz.glang.model.*;
%}

%%

entrypoint: statementList
{
    this.entryPoint = (ParseNode) $1;
}
;

statementList: statement SEMI
{
    $$ = new StatementListNode((StatementNode) $1);
}
| statementList statement SEMI
{
    ((StatementListNode) $1).add((StatementNode) $2);
    $$ = $1;
}
;

statement: declaration
| assign
| output
| input
| while
| for
;

while: WHILE LPAREN expr RPAREN LCURLY statementList RCURLY
{
    $$ = new WhileStatementNode((ParseNode)$3, (StatementListNode)$6);
};

for: FOR LPAREN assign SEMI expr SEMI assign RPAREN LCURLY statementList RCURLY
{
    $$ = new ForStatementNode((AssignmentNode)$3, (ParseNode)$5, (AssignmentNode)$7, (StatementListNode)$10);
}
;

declaration: INT ID
{
    $$ = new DeclarationNode(Type.INT, (String) $2);
}
| DOUBLE ID
{
    $$ = new DeclarationNode(Type.DOUBLE, (String) $2);
}
| STRING ID
{
    $$ = new DeclarationNode(Type.STRING, (String) $2);
}
| CHARACTER ID
{
    $$ = new DeclarationNode(Type.CHAR, (String) $2);
}
| arrayDeclaration
;

arrayDeclaration: INT ID LSQUARE expr RSQUARE
{
    $$ = new ArrayDeclarationNode(Type.INT, (String) $2, (ParseNode) $4);
}
| DOUBLE ID LSQUARE expr RSQUARE
{
    $$ = new ArrayDeclarationNode(Type.DOUBLE, (String) $2, (ParseNode) $4);
}
| STRING ID LSQUARE expr RSQUARE
{
    $$ = new ArrayDeclarationNode(Type.STRING, (String) $2, (ParseNode) $4);
}
| CHARACTER ID LSQUARE expr RSQUARE
{
    $$ = new ArrayDeclarationNode(Type.CHAR, (String) $2, (ParseNode) $4);
}
| arrayDeclaration LSQUARE expr RSQUARE
{
    ((ArrayDeclarationNode)$1).setMulti(true, (ParseNode)$3);
    $$ = $1;
}
;

assign: ref EQUAL expr
{
    $$ = new AssignmentNode((ReferenceNode)$1, (ParseNode)$3);
}
| declaration EQUAL expr
{
    $$ = new AssignmentNode((DeclarationNode)$1, (ParseNode)$3);
}
;

output: PRINT expr
{
    $$ = new StdOutNode((ParseNode)$2);
}
;

input: READ ref
{
    $$ = new StdInNode((ReferenceNode) $2);
}
;

expr: term SUB expr
{
    $$ = new BinaryOperationNode((ParseNode) $1, "-", (ParseNode) $3);
}
| term ADD expr
{
    $$ = new BinaryOperationNode((ParseNode) $1, "+", (ParseNode) $3);
}
| term
;

term: term MULTIPLY factor
{
    $$ = new BinaryOperationNode((ParseNode) $1, "*", (ParseNode) $3);
}
| term DIVIDE factor
{
    $$ = new BinaryOperationNode((ParseNode) $1, "/", (ParseNode) $3);
}
| factor
;

factor: factor POW unary
{
    $$ = new BinaryOperationNode((ParseNode) $1, "^", (ParseNode) $3);
}
| unary
;

unary: SUB group
{
    $$ = new UnaryOperationNode("-", (ParseNode) $2 );
}
| group
;

group: LPAREN expr RPAREN
{
    $$ = new GroupNode((ParseNode)$2);
}
| ref
| LITERAL
{
    $$ = new Symbol(Type.INT, "int-literal", (Integer) $1);
}
| DOUBLE
{
    $$ = new Symbol(Type.DOUBLE, "double-literal", (Double) $1);
}
| string
| char
;

ref: ID
{
    $$ = new ReferenceNode((String) $1);
}
| ref LSQUARE expr RSQUARE
{
    $$ = new ArrayReferenceNode((ReferenceNode) $1, (ParseNode) $3);
}
;

string: DQUOTE CHARS DQUOTE
{
    $$ = new Symbol(Type.STRING, "string-literal", (String) $2);
}
;

char: QUOTE CHAR QUOTE
{
    $$ = new Symbol(Type.CHAR, "char-literal", (char) $2);
}
;

%%
    private Lexer lexer;
    private ParseNode entryPoint;
    private ParseNode currentNode;

    public Parser(java.io.InputStream in)
    {
        lexer = new Lexer(in);
        new ParseTree();
    }


    public ParseNode getEntryPoint()
    {
        return entryPoint;
    }

    /*SymbolTable addDeclaration(Object sym, Object decl) {
        if(sym == null)
            sym = new SymbolTable();
        SymbolTable table = (SymbolTable)sym;
        DeclarationNode declaration = (DeclarationNode)decl;
        table.set(declaration.getName(), new Symbol(declaration.getType(), "declaration", null));
        return table;
    }*/


    public int next() {
        lexer.next();
        return lexer.getToken();
    }


    public void yyerror(String msg) {
        lexer.printError("ERROR: " + msg);
    }


    public static void main(String [] args) {
        try {
            Parser parser = new Parser(new java.io.FileInputStream(args[0]));
            parser.next();
            if(parser.parse()) {
                parser.getEntryPoint().setEnvironment(ParseTree.get());
                parser.getEntryPoint().evaluate();
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
